# PYTHON CODING STANDARDS & EXECUTION PROTOCOLS

## 1. Python Coding Standards
All code generated must strictly adhere to the following rules:

### A. Style & Formatting
- **Repo First:** Follow existing repo lint/format configs (ruff/black/isort/etc.) if present.
- **PEP 8:** Follow PEP 8 for indentation, spacing, and naming.
- **Naming:**
  - Variables/Functions: `snake_case`
  - Classes: `PascalCase`
  - Constants: `UPPER_CASE`
- **Imports:** Standard library -> Third-party -> Local application.

### B. Type Hinting & Docstrings (MANDATORY)
- **Type Hints:** All function args + return must have type hints.
- **Docstrings:** Every module, class, and public function must have a docstring (Google/NumPy):
  - Purpose, Args, Returns, Raises (if applicable).

### C. Error Handling
- Catch specific exceptions (e.g., `except ValueError:`).
- **NEVER** use bare `except:` except at top-level entry point for logging.

### D. Tests (MANDATORY when behavior changes)
- If behavior changes, **MUST** add/update tests.

### E. Security & Secrets (CRITICAL)
- **NO HARDCODED SECRETS:** Never commit API keys, passwords, or private keys.
- **Environment Variables:** Use `os.getenv()` or `pydantic-settings`.
- **.gitignore:** Ensure any new output files or data directories are added to `.gitignore`.

### F. Database & SQL Interactions
- **No F-strings in SQL:** Always use parameterized queries to prevent SQL Injection.
- **Performance:** Avoid `SELECT *` on large tables (especially ClickHouse). Select only required columns.
- **Migration:** If schema changes, create a migration file/script; do not run raw DDL via generic execution unless specified.

### G. Dependency Management
- **Tooling:** uv add {package} if uv.lock exists, or poetry add {package} if poetry.lock exists. If neither is present, default to using uv.
- **Lock File:** Always ensure the corresponding lock file (uv.lock or poetry.lock) is updated after adding packages.

- **Execution:** Execution: Run scripts or commands using uv run {command} or poetry run {command} respectively, based on the tool identified above.
---

## 2. Execution Logging Protocol (CRITICAL)
Every time an agent modifies the codebase (create/update/delete/refactor/rename/move), it MUST log the action.

### Log Location (MANDATORY)
All logs MUST be stored under:
`.agent-execution/{task_name}/log/execution__{plan_file_stem}.md`

Where:
- `{task_name}` = folder name generated by Planning Agent (snake_case)
- `{plan_file_stem}` = the assigned plan filename WITHOUT `.md`
  (example: `01_backend_api__owner_coding_backend_agent`)

Rules:
- Always append. Never overwrite.
- Create directories if missing.
- The log file name MUST be derived from the plan file stem (no manual naming).

### Log Entry Format
```markdown
## [YYYY-MM-DD HH:MM:SS] Task: {Brief Task Title}
- **Action:** [Create | Update | Delete | Refactor | Rename/Move]
- **Files Affected:**
  - `path/to/file1.py`
- **Summary:** {What changed + why (1-3 lines).}
- **Verify:** {Command(s) or steps to confirm.}
- **Status:** âœ… Success | âš ï¸ Partial | âŒ Failed
```

---

## 3. Communication Protocol (Senior Engineer Persona)
When implementing complex features or refactoring, follow this structure in your response:

### 1. Trade-offs & Decisions (Mental Sandbox)
- Briefly list options considered before settling on the solution.
- **Example:** "Why manual SQL vs ORM? Why Redis vs In-memory? Why Async vs Threading?"
- Highlight any potential technical debt being introduced for speed.

### 2. Implementation
- The code itself (strictly following Section 1 standards).

### 3. Operational Concerns & Edge Cases
- **Monitoring:** How do we know if this breaks in production? (Logs, metrics).
- **Edge Cases:** What happens with large inputs, timeouts, or empty states?
- **Security:** Explicitly mention if input validation or auth checks were added.

---

## 4. Implementation Workflow (Problem Solving Mindset)
Before writing any code for a significant change (>10 lines or cross-file impact):

1.  **Stop & Think ğŸ›‘:** Outline the plan in 3-5 bullet points in your response.
2.  **Verify Context ğŸ”:** Confirm you have read all relevant files (imports, base classes, config).
3.  **Execute ğŸš€:** Write code tailored to the plan.
